using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;
using Random = UnityEngine.Random;

/// <summary>
/// Generates a perfect maze using IterativeBacktracker.
/// Adapted from <see href="https://github.com/n-c0de-r/TaurosTraps">one of my own older projects</see>.
/// As inspired by the visual demo of <see href="https://www.jamisbuck.org/mazes/">Jamis Buck</see>.
/// </summary>
public class MazeGenerator : MonoBehaviour
{
    #region Serialized Fields

    [SerializeField]
    private Tilemap wallMap;

    [SerializeField]
    private Tile[] wallTiles;

    #endregion


    #region Fields

    /// <summary>
    /// The maze grid, where 0 means no path, any other (1-15) a connection.
    /// </summary>
    private int[,] maze;

    /// <summary>
    /// Structs holding information on directions.
    /// </summary>
    private Direction[] directions;

    /// <summary>
    /// The stack of cells for iterative backtracker.
    /// </summary>
    private Stack<Cell> cells;

    /// <summary>
    /// Stack for each of the parallelly running backtrackers
    /// </summary>
    private Stack<Cell>[] stacks;

    /// <summary>
    /// Sizes can't be negative and never exceed 250 in the original project,
    /// bytes would fit well, but integers are easier on coding further.
    /// </summary>
    private int width, height;

    #endregion


    #region Methods

    /// <summary>
    /// Generates a new maze.
    /// Using the Iterative Backtracker method.
    /// </summary>
    public void GenerateMaze()
    {
        ResetAll();

        StartCoroutine(IterativeBacktracker());

        PaintMap(maze, width, height);
    }

    /// <summary>
    /// Iterates over the given data and lays tiles accordingly.
    /// </summary>
    /// <param name="mazeData">The data table generated by the Maze Generator.</param>
    /// <param name="mazeWidth">Width of the maze to draw.</param>
    /// <param name="mazeHeight">Height of the maze draw.</param>
    public void PaintMap(int[,] mazeData, int mazeWidth, int mazeHeight)
    {
        // Visualize the data as numbers. Uncomment if needed
        /*Debug.Log("Maze generated");
        String s = "";
        for (int y = 0; y < mazeHeight; y++)
        {
            for (int x = 0; x < mazeWidth; x++)
            {
                if (mazeData[x, y] < 10)
                {
                    s += "0" + mazeData[x, y] + " ";
                }
                else
                {
                    s += mazeData[x, y] + " ";
                }
            }
            s += "\n";
        }
        Debug.Log(s);*/

        wallMap.ClearAllTiles();

        Vector3Int pos = new(0, 0, 0);

        for (int y = 0; y < mazeHeight; y++)
        {
            for (int x = 0; x < mazeWidth; x++)
            {
                pos.x = x - mazeWidth / 2;
                pos.y = y - mazeHeight / 2;

                wallMap.SetTile(pos, wallTiles[mazeData[x, mazeHeight - y - 1]]);
            }
        }
    }

    /// <summary>
    /// Returns the maps bound size.
    /// </summary>
    /// <returns>The number of set tiles.</returns>
    public Bounds GetBounds()
    {
        wallMap.CompressBounds();
        return wallMap.localBounds;
    }

    #endregion


    #region Helpers

    /// <summary>
    /// Resets everything prior to generation.
    /// </summary>
    private void ResetAll()
    {
        directions = new Direction[] {
            new(1, 0, -1),    // North
            new(2, 1, 0),     // East
            new(4, 0, 1),     // South
            new(8, -1, 0),    // West
        };

        cells = new Stack<Cell>();

        stacks = new Stack<Cell>[4] {
            new(),
            new(),
            new(),
            new()
        };

        ResetMaze();
        ClearMaze();
        InitializeStack();
    }

    /// <summary>
    /// Resets the maze holding array.
    /// </summary>
    private void ResetMaze()
    {
        if (maze != null && (maze.GetLength(0) == width && maze.GetLength(1) == height))
            return;

        maze = new int[width, height];
    }

    /// <summary>
    /// Set the starting cells to all walls / no paths (0)
    /// </summary>
    private void ClearMaze()
    {
        Array.Clear(maze, 0, (width * height));
    }

    /// <summary>
    /// Clears all stacks and initializes first cell.
    /// </summary>
    private void InitializeStack()
    {
        cells.Clear();
        cells.Push(new Cell(Random.Range(0, width >> 1), Random.Range(0, height >> 1)));

        int halfX = width >> 1;    // Half the size, for starting positions of
        int halfY = height >> 1;    // the four starting cells in each quadrant

        // Starting Cells for each quadrant for the parallelly running backtrackers
        Cell[] starters = new Cell[4] {
            new(Random.Range(0, halfX),    Random.Range(0, halfY)),        // Up left 
            new(Random.Range(halfX, width),Random.Range(0, halfY)),        // Up right
            new(Random.Range(0, halfX),    Random.Range(halfY, height)),   // Down left
            new(Random.Range(halfX, width),Random.Range(halfY, height)),   // Down right
        };

        for (int i = 0; i < stacks.Length; i++)
        {
            stacks[i].Clear();
            stacks[i].Push(starters[i]);
        }
    }

    /// <summary>
    /// The actual implementation of the generating algorithm.
    /// Using the Iterative Backtracking approach.
    /// </summary>
    /// <returns>An enumerator.</returns>
    private IEnumerator IterativeBacktracker()
    {
        while (cells.Count > 0)
        {
            Cell current = cells.Pop();

            ShuffleDirections(directions);

            foreach (Direction dir in directions)
            {
                int newX = current.x + dir.x;
                int newY = current.y + dir.y;

                if (IsValidMove(newX, newY))
                {
                    maze[current.x, current.y] |= dir.value;
                    maze[newX, newY] |= dir.opposite;

                    cells.Push(new Cell(newX, newY));
                }
            }
        }
        yield return null;
    }

    /// <summary>
    /// Check if a move to the given coordinates is valid (within the bounds of the maze and not already visited)
    /// </summary>
    /// <param name="x">The X coordinate of the cell to check.</param>
    /// <param name="y">The Y coordinate of the cell to check.</param>
    /// <returns>True or false if the cell is valid or not.</returns>
    private bool IsValidMove(int x, int y)
    {
        return x >= 0 && x < width && y >= 0 && y < height && maze[x, y] == 0;
    }

    /// <summary>
    /// Shuffles the array of directions.
    /// </summary>
    /// <param name="original">The array to shuffle.</param>
    private void ShuffleDirections(Direction[] original)
    {
        int n = original.Length;
        while (n > 1)
        {
            int k = Random.Range(0, n--);
            (original[k], original[n]) = (original[n], original[k]);
        }
    }

    #endregion


    #region Inner Structs

    /// <summary>
    /// Represents Cells in a maze
    /// </summary>
    public struct Cell
    {
        /// <summary>
        /// X coordinate, represents the cell to visit next.
        /// </summary>
        public int x;

        /// <summary>
        /// Y coordinate, represents the cell to visit next.
        /// </summary>
        public int y;

        /// <summary>
        /// Consturctor of a Cell struct.
        /// </summary>
        /// <param name="newX">New X coordinate to set.</param>
        /// <param name="newY">New Y coordinate to set.</param>
        public Cell(int newX, int newY)
        {
            this.x = newX;
            this.y = newY;
        }
    }

    /// <summary>
    /// Struct holding values relevant for carving directions in a maze.
    /// </summary>
    public struct Direction
    {
        /// <summary>
        /// Number representation of a direction, to use bitwise operations on.
        /// </summary>
        public int value;

        /// <summary>
        /// X coordinate, represents the cell to visit next.
        /// </summary>
        public int x;

        /// <summary>
        /// Y coordinate, represents the cell to visit next.
        /// </summary>
        public int y;

        /// <summary>
        /// The opposite value of the original, calculated automatically.
        /// </summary>
        public int opposite;

        /// <summary>
        /// Consturctor of a Direction struct.
        /// </summary>
        /// <param name="newValue">New value to set. </param>
        /// <param name="newX">New X coordinate to set.</param>
        /// <param name="newY">New Y coordinate to set.</param>
        public Direction(int newValue, int newX, int newY)
        {
            this.value = newValue;
            this.x = newX;
            this.y = newY;
            this.opposite = (value << 2) % 15; // Automatically calculates the opposite.
        }
    }

    #endregion
}
